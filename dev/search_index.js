var documenterSearchIndex = {"docs":
[{"location":"api/estimator/#Estimator","page":"Estimator","title":"Estimator","text":"","category":"section"},{"location":"api/estimator/","page":"Estimator","title":"Estimator","text":"SLAM.Estimator","category":"page"},{"location":"api/estimator/#SLAM.Estimator","page":"Estimator","title":"SLAM.Estimator","text":"Estimator is responsible for performing Bundle-Adjustment procedure and map filtering that removes low-information Keyframes from the map.\n\nArguments:\n\nmap_manager::MapManager: Map manager with all the map information.\nparams::Params: Parameters of the system.\nframe_queue::Vector{Frame}: Queue of the Frames to process.\nnew_kf_available::Bool: Whether or not new Keyframe in the queue   is available.\nexit_required::Bool: Whether the estimator should end its work and exit.\nqueue_lock:ReentrantLock: Lock for the queue.\n\n\n\n\n\n","category":"type"},{"location":"api/estimator/","page":"Estimator","title":"Estimator","text":"run!(::SLAM.Estimator)\nSLAM.add_new_kf!\nSLAM.get_new_kf!","category":"page"},{"location":"api/estimator/#SLAM.run!-Tuple{SLAM.Estimator}","page":"Estimator","title":"SLAM.run!","text":"run!(estimator::Estimator)\n\nMain routine that starts Estimator.\n\n\n\n\n\n","category":"method"},{"location":"api/estimator/#SLAM.add_new_kf!","page":"Estimator","title":"SLAM.add_new_kf!","text":"add_new_kf!(estimator::Estimator, frame::Frame)\n\nAdd frame to the Estimator queue to be processed.\n\n\n\n\n\n","category":"function"},{"location":"api/estimator/#SLAM.get_new_kf!","page":"Estimator","title":"SLAM.get_new_kf!","text":"get_new_kf!(estimator::Estimator)\n\nGet frame from the queue if it is available.\n\n\n\n\n\n","category":"function"},{"location":"api/estimator/","page":"Estimator","title":"Estimator","text":"SLAM.local_bundle_adjustment!\nSLAM.map_filtering!","category":"page"},{"location":"api/estimator/#SLAM.local_bundle_adjustment!","page":"Estimator","title":"SLAM.local_bundle_adjustment!","text":"local_bundle_adjustment!(estimator::Estimator, new_frame::Frame)\n\nPerform Bundle-Adjustment on the new frame and its covisibility graph.\n\nMinimize error function over all KeyFrame's extrinsic parameters in the covisibility graph and their corresponding MapPoint's positions. Afterwards, update these parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/estimator/#SLAM.map_filtering!","page":"Estimator","title":"SLAM.map_filtering!","text":"map_filtering!(estimator::Estimator, new_keyframe::Frame)\n\nFilter out KeyFrames that share too many MapPoints with other KeyFrames in the covisibility graph. Since they are not informative.\n\n\n\n\n\n","category":"function"},{"location":"api/estimator/","page":"Estimator","title":"Estimator","text":"reset!(::SLAM.Estimator)","category":"page"},{"location":"api/estimator/#SLAM.reset!-Tuple{SLAM.Estimator}","page":"Estimator","title":"SLAM.reset!","text":"reset!(estimator::Estimator)\n\nReset Estimator.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#IO","page":"IO","title":"IO","text":"","category":"section"},{"location":"api/io/","page":"IO","title":"IO","text":"Visualizer\nset_frame_wc!(::Visualizer, ::Int64, ::Matrix{Float64})\nprocess_frame_wc!\nset_image!\nset_position!","category":"page"},{"location":"api/io/#SLAM.Visualizer","page":"IO","title":"SLAM.Visualizer","text":"Visualizer for the SLAM.\n\nCan be used to play in \"live\" mode as the SLAM is working or to replay from ReplaySaver.\n\nUsage:\n\nTo use it in \"live\" preview mode, pass it as a keyword argument, when creating SlamManager:\n\nvisualizer = Visualizer(;resolution=(900, 600), image_resolution=(370, 1226))\nSlamManager(params, camera; visualizer)\n\n\n\n\n\n","category":"type"},{"location":"api/io/#SLAM.set_frame_wc!-Tuple{Visualizer, Int64, Matrix{Float64}}","page":"IO","title":"SLAM.set_frame_wc!","text":"set_frame_wc!(v::Visualizer, frame_id, wc)\n\nAdd new frame wc to the visualizer queue. This is used when other threads are updating the visualizer.\n\nThe queue is processed in process_frame_wc! method.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#SLAM.process_frame_wc!","page":"IO","title":"SLAM.process_frame_wc!","text":"process_frame_wc!(v::Visualizer)\n\nProcess pose queue. This updates the plot immediately.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#SLAM.set_image!","page":"IO","title":"SLAM.set_image!","text":"set_image!(v::Visualizer, image)\n\nUpdate image in the visualizer. It should have the same dimensions as the original.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#SLAM.set_position!","page":"IO","title":"SLAM.set_position!","text":"set_position!(v::Visualizer, position)\n\nAdd new position to the camera positions. This updates the plot immediately.\n\n\n\n\n\n","category":"function"},{"location":"api/io/","page":"IO","title":"IO","text":"ReplaySaver\nset_frame_wc!(::ReplaySaver, ::Int64, ::Matrix{Float64})\nSLAM.save\nSLAM.load!","category":"page"},{"location":"api/io/#SLAM.ReplaySaver","page":"IO","title":"SLAM.ReplaySaver","text":"ReplaySaver()\n\nReplaySaver is used to save/load SLAM result for the visualizer. If added to the SlamManager instead of the visualizer, it accumulates poses needed for the visualization/replay and can be later used to replay the results.\n\nUsage:\n\nTo use it, pass it to visualizer keyword argument, when creating SlamManager. Do some work, and in the end, save it to the directory.\n\nsaver = ReplaySaver()\nSlamManager(params, camera; visualizer=saver)\n# ...run slam...\nSLAM.save(saver, \"save_dir\")\n\nThen you can load it from the save directory and use it to replay results.\n\nSLAM.load!(saver, \"save_dir\")\n\n\n\n\n\n","category":"type"},{"location":"api/io/#SLAM.set_frame_wc!-Tuple{ReplaySaver, Int64, Matrix{Float64}}","page":"IO","title":"SLAM.set_frame_wc!","text":"set_frame_wc!(saver::ReplaySaver, frame_id, wc)\n\nAdd new pose to store.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#SLAM.save","page":"IO","title":"SLAM.save","text":"save(saver::ReplaySaver, save_dir)\n\nSave results into the given directory.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#SLAM.load!","page":"IO","title":"SLAM.load!","text":"load!(saver::ReplaySaver, save_dir)\n\nLoad results from a given directory.\n\n\n\n\n\n","category":"function"},{"location":"api/map-manager/#Map-Manager","page":"Map Manager","title":"Map Manager","text":"","category":"section"},{"location":"api/map-manager/","page":"Map Manager","title":"Map Manager","text":"SLAM.MapManager","category":"page"},{"location":"api/map-manager/#SLAM.MapManager","page":"Map Manager","title":"SLAM.MapManager","text":"MapManager(params::Params, frame::Frame, extractor::Extractor)\n\nMap Manager is responsible for managing Keyframes in the map as well as Mappoints.\n\nArguments:\n\ncurrent_frame::Frame: Current frame that is shared throughout   all the components in the system.\nframes_map::Dict{Int64, Frame}: Map of the Keyframes (its id → Keyframe).\nparams::Params: Parameters of the system.\nextractor::Extractor: Extractor for finding keypoints in the frames.\nmap_points::Dict{Int64, MapPoint}: Map of all the map_points   (its id → MapPoints).\ncurrent_mappoint_id::Int64: Id of the current Mappoint to be created.   It is incremented each time a new Mappoint is added to map_points.\ncurrent_keyframe_id::Int64: Id of the current Keyframe to be created.   It is incremented each time a new Keyframe is added to frames_map.\nnb_keyframes::Int64: Total number of keyframes.\nnb_mappoints::Int64: Total number of mappoints.\n\n\n\n\n\n","category":"type"},{"location":"api/map-manager/","page":"Map Manager","title":"Map Manager","text":"SLAM.update_frame_covisibility!\nSLAM.merge_mappoints\nSLAM.optical_flow_matching!\nSLAM.maybe_stereo_update!","category":"page"},{"location":"api/map-manager/#SLAM.update_frame_covisibility!","page":"Map Manager","title":"SLAM.update_frame_covisibility!","text":"update_frame_covisibility!(map_manager::MapManager, frame::Frame)\n\nUpdate covisibility graph for the frame. This is done by going through all of the keypoints in the frame. Getting their corresponding mappoints. And joining sets of observers for those mappoints.\n\n\n\n\n\n","category":"function"},{"location":"api/map-manager/#SLAM.merge_mappoints","page":"Map Manager","title":"SLAM.merge_mappoints","text":"merge_mappoints(m::MapManager, prev_id, new_id)\n\nMerge prev_id Mappoint into new_id Mappoint. For \"previous\" observers, update mappoint and keypoint to the new.\n\n\n\n\n\n","category":"function"},{"location":"api/map-manager/#SLAM.optical_flow_matching!","page":"Map Manager","title":"SLAM.optical_flow_matching!","text":"optical_flow_matching!(map_manager, frame, from_pyramid, to_pyramid, stereo)\n\nMatch keypoints in frame from from_pyramid to to_pyramid. This function is used when matching keypoints temporally from previous frame to current frame, or when matching keypoints between stereo image.\n\nIf there are 3D keypoints in the frame, then try to match respectful keypoints using displacement guess from motion model (when matching temporally) or calibration pose (in stereo).\n\nArguments\n\nmap_manager::MapManager: Map manager, used for retrieving parameters info,   3D mappoints, removing mappoints.\nframe: Frame for which to do matching.\nfrom_pyramid::LKPyramid: Pyramid from which to track.\nto_pyramid::LKPyramid: Pyramid to which to track.\nstereo::Bool: Set to true if doing stereo matching. It will retrieve data   using mutex and update stereo keypoints instead of regular keypoints.   Otherwise set to false.\n\n\n\n\n\n","category":"function"},{"location":"api/map-manager/#SLAM.maybe_stereo_update!","page":"Map Manager","title":"SLAM.maybe_stereo_update!","text":"maybe_stereo_update!(\n    frame::Frame, kpid, new_position::Point2f; epipolar_error::Float64 = 2.0,\n)\n\nUpdate stereo keypoint if the vertical distance between matched keypoints is less than epipolar_error. In this case, set y-coordinate equal to the left keypoint. Otherwise do nothing.\n\nReturns:\n\ntrue if successfully updated, otherwise false.\n\n\n\n\n\n","category":"function"},{"location":"api/map-manager/","page":"Map Manager","title":"Map Manager","text":"reset!(::SLAM.MapManager)","category":"page"},{"location":"api/map-manager/#SLAM.reset!-Tuple{SLAM.MapManager}","page":"Map Manager","title":"SLAM.reset!","text":"reset!(m::MapManager)\n\nReset map manager.\n\n\n\n\n\n","category":"method"},{"location":"api/front-end/#Front-End","page":"Front-End","title":"Front-End","text":"","category":"section"},{"location":"api/front-end/","page":"Front-End","title":"Front-End","text":"SLAM.FrontEnd","category":"page"},{"location":"api/front-end/#SLAM.FrontEnd","page":"Front-End","title":"SLAM.FrontEnd","text":"Front-End is responsible for tracking keypoints and computing poses for the Frames. It also decides when the system needs a new Keyframe in the map.\n\nParameters:\n\ncurrent_frame::Frame: Current frame that is being processed.   This is a shared Frame between FrontEnd, MapManager, Estimator   and SlamManager.\nmotion_model::MotionModel: Motion model that is used to predict   pose for the Frame before the actual pose for it was computed.\nmap_manager::MapManager: Map manager that is responsible for the   creation of new Keyframes in the map.\nparams::Params: Parameters of the system.\ncurrent_image::Matrix{Gray{Float64}}: Current image that is processed.\nprevious_image::Matrix{Gray{Float64}}: Previous processed image.\ncurrent_pyramid::LKPyramid: Pre-computed pyramid   that is used for optical flow tracking for the current_image.\nprevious_pyramid::LKPyramid: Pre-computed pyramid   that is used for optical flow tracking for the previous_image.\n\n\n\n\n\n","category":"type"},{"location":"api/front-end/","page":"Front-End","title":"Front-End","text":"SLAM.track!\nSLAM.klt_tracking!\nSLAM.compute_pose!\nSLAM.compute_pose_5pt!","category":"page"},{"location":"api/front-end/#SLAM.track!","page":"Front-End","title":"SLAM.track!","text":"track!(fe::FrontEnd, image, time)\n\nGiven an image and time at which it was taken, track keypoints in it. After tracking, decide if the system needs a new Keyframe added to the map. If it is the first image to be tracked, then Keyframe is always needed.\n\nReturns:\n\ntrue if the system needs a new Keyframe, otherwise false.\n\n\n\n\n\n","category":"function"},{"location":"api/front-end/#SLAM.klt_tracking!","page":"Front-End","title":"SLAM.klt_tracking!","text":"klt_tracking!(fe::FrontEnd)\n\nTrack keypoints from previous frame to current frame.\n\n\n\n\n\n","category":"function"},{"location":"api/front-end/#SLAM.compute_pose!","page":"Front-End","title":"SLAM.compute_pose!","text":"compute_pose!(fe::FrontEnd)\n\nCompute pose of a current Frame using P3P Ransac algorithm. Pose is computed from the triangulated Keypoints (MapPoints) that are visible in this frame.\n\nReturns:\n\ntrue if the pose was successfully computed and applied to current Frame, otherwise false.\n\n\n\n\n\n","category":"function"},{"location":"api/front-end/#SLAM.compute_pose_5pt!","page":"Front-End","title":"SLAM.compute_pose_5pt!","text":"compute_pose_5pt!(fe::FrontEnd; min_parallax, use_motion_model)\n\nCopmute pose for pixel correspondences using 5-point algorithm to recover essential matrix, then pose from it.\n\nArguments:\n\nmin_parallax: Minimum parallax required between pixels in the current Frame   and previous Keyframe to compute pose.   Note, that parallax is rotation-compensated, meaning a rotation from   current to previous frame is computed and applied to every pixel.\nuse_motion_model: If true, then use constant-velocity motion model   to predict next pose from previous frame.   Otherwise, the computed pose will be \"local\".\n\nReturns:\n\nIf successfull, 4x4 pose matrix, that transforms points from previous Keyframe to current Frame. Otherwise nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/front-end/","page":"Front-End","title":"Front-End","text":"SLAM.check_ready_for_init!\nSLAM.check_new_kf_required\nSLAM.compute_parallax","category":"page"},{"location":"api/front-end/#SLAM.check_ready_for_init!","page":"Front-End","title":"SLAM.check_ready_for_init!","text":"check_ready_for_init!(fe::FrontEnd)\n\nCheck if there is enough average rotation compensated parallax between current Frame and previous KeyFrame.\n\nAdditionally, compute Essential matrix using 5-point Ransac algorithm to filter out outliers and check if there is enough inliers to proceed.\n\n\n\n\n\n","category":"function"},{"location":"api/front-end/#SLAM.check_new_kf_required","page":"Front-End","title":"SLAM.check_new_kf_required","text":"check_new_kf_required(fe::FrontEnd)\n\nCheck if we need to insert a new KeyFrame into the Map.\n\n\n\n\n\n","category":"function"},{"location":"api/front-end/#SLAM.compute_parallax","page":"Front-End","title":"SLAM.compute_parallax","text":"compute_parallax(\n    fe::FrontEnd, current_frame_id;\n    compensate_rotation = true, only_2d = true, median_parallax = true,\n)\n\nCompute parallax in pixels between current Frame and the provided current_frame_id Frame.\n\nArguments:\n\ncompensate_rotation::Bool:   Compensate rotation by computing relative rotation between   current Frame and previous Keyframe if true. Default is true.\nonly_2d::Bool: Consider only 2d keypoints. Default is true.\nmedian_parallax::Bool:   Instead of the average, compute median parallax. Default is true.\n\n\n\n\n\n","category":"function"},{"location":"api/front-end/","page":"Front-End","title":"Front-End","text":"SLAM.reset_frame!(::SLAM.FrontEnd)\nreset!(::SLAM.FrontEnd)","category":"page"},{"location":"api/front-end/#SLAM.reset_frame!-Tuple{SLAM.FrontEnd}","page":"Front-End","title":"SLAM.reset_frame!","text":"reset_frame!(fe::FrontEnd)\n\nReset current Frame in Front-End.\n\n\n\n\n\n","category":"method"},{"location":"api/front-end/#SLAM.reset!-Tuple{SLAM.FrontEnd}","page":"Front-End","title":"SLAM.reset!","text":"reset!(fe::FrontEnd)\n\nReset Front-End.\n\n\n\n\n\n","category":"method"},{"location":"api/slam-manager/#Slam-Manager","page":"Slam Manager","title":"Slam Manager","text":"","category":"section"},{"location":"api/slam-manager/","page":"Slam Manager","title":"Slam Manager","text":"SlamManager\nrun!(::SlamManager)\nadd_image!\nadd_stereo_image!\nget_queue_size\nreset!(::SlamManager)","category":"page"},{"location":"api/slam-manager/#SLAM.SlamManager","page":"Slam Manager","title":"SLAM.SlamManager","text":"SlamManager(\n    params::Params, camera::Camera;\n    right_camera::Union{Nothing, Camera} = nothing,\n)\n\nSlam Manager that is the highest level component in the system. It is responsible for sending new frames to the other components and for processing their outputs.\n\nNote, that upon creating, SlamManager launches Mapper in the separate thread.\n\nArguments\n\nparams::Params: Parameters of the system.\nimage_queue::Vector{Matrix{Gray{Float64}}}: Queue of the images to be   processed.\nright_image_queue::Vector{Matrix{Gray{Float64}}}: In case of stereo mode,   queue of images for the right camera.   It should be in sync with image_queue which in this case is for the left   camera.\ntime_queue::Vector{Float64}: Queue of timestamps for each of the frame.   The timestamps are used in the motion model to predict next pose for the   frame, before it is actually computed.\ncurrent_frame::Frame: Current frame that is processed. It is shared among   all other components in the system.\nframe_id::Int64: Id of the current frame.\nfront_end::FrontEnd: Front-End component that is used for tracking.\nmap_manager::MapManager: Map manager for the managment of   keyframes & mappoints.\nmapper::Mapper: Mapper that is used for triangulation of keypoints.   It is launched in the constructor as a separate thread.\nextractor::Extractor: Used in extraction of keypoints from the frames.\nexit_required::Bool: Set it to true to stop SlamManager   once it is launched.\n\n\n\n\n\n","category":"type"},{"location":"api/slam-manager/#SLAM.run!-Tuple{SlamManager}","page":"Slam Manager","title":"SLAM.run!","text":"run!(sm::SlamManager)\n\nMain routine for the SlamManager. It runs until exit_required variable is set to true. After that, it will end its work, wait for other threads and finish.\n\nOnce there is a frame in the queue, it will get it and first send it to the FrontEnd for tracking. If FrontEnd requires a new Keyframe, then it will also send it to the mapper thread for Keyframe creation and triangulation.\n\n\n\n\n\n","category":"method"},{"location":"api/slam-manager/#SLAM.add_image!","page":"Slam Manager","title":"SLAM.add_image!","text":"add_image!(sm::SlamManager, image, time)\n\nAdd monocular image and its timestamp to the queue.\n\n\n\n\n\n","category":"function"},{"location":"api/slam-manager/#SLAM.add_stereo_image!","page":"Slam Manager","title":"SLAM.add_stereo_image!","text":"add_stereo_image!(sm::SlamManager, image, right_image, time)\n\nAdd stereo image and its timestamp to the queue.\n\n\n\n\n\n","category":"function"},{"location":"api/slam-manager/#SLAM.get_queue_size","page":"Slam Manager","title":"SLAM.get_queue_size","text":"get_queue_size(sm::SlamManager)\n\nGet size of the queue of images to be processed.\n\n\n\n\n\n","category":"function"},{"location":"api/slam-manager/#SLAM.reset!-Tuple{SlamManager}","page":"Slam Manager","title":"SLAM.reset!","text":"reset!(sm::SlamManager)\n\nReset slam manager, front-end and map_manager.\n\n\n\n\n\n","category":"method"},{"location":"#SLAM.jl","page":"Home","title":"SLAM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simultaneous Localization and Mapping.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Monocular / Stereo modes.\nBundle-Adjustment over a subset of Keyframes.\nLocal Map Matching for re-tracking lost Mappoints back into Frame.","category":"page"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"]add https://github.com/pxl-th/RecoverPose.jl.git\n]add https://github.com/pxl-th/SLAM.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"RecoverPose.jl contains functions for computing poses and triangulation methods.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Minimal abstract example of how to use.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SLAM\n\ncamera = Camera(...)\nparams = Params(; stereo=false, ...)\nmanager = SlamManager(camera, params)\nmanager_thread = Threads.@spawn run!(manager)\n\nimages = Matrix{Gray{Float64}}[...]\ntimestamps = Float64[...]\n\nfor (time, image) in zip(timestamps, images)\n    add_image!(manager, image, timestamp)\n    sleep(1e-2)\nend\n\nmanager.exit_required = true\nwait(manager_thread)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a more detailed explanation, see Tutorial section. If you prefer looking at raw code instead, look at a complete KITTY Dataset example.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThese are 3 components in the SLAM.jl that need to run on a separate thread. So, remember to launch Julia with at least -t4 flag (+ 1 for the main thread).","category":"page"},{"location":"#Results","page":"Home","title":"Results","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Final map on the 00 sequence taken from KITTY dataset in stereo mode.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: KITTY 00 sequence)","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Launch-SlamManager-routine","page":"Tutorial","title":"Launch SlamManager routine","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"warning: Warning\nThere are 3 components in the SLAM.jl that need to run on a separate thread. So, remember to launch Julia with at least -t4 flag (+ 1 for the main thread).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To launch SLAM algorithm, first we need to set up the Camera and Parameters.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One of the main things you need to specify in parameters is mode (stereo or mono). For other parameters, refer to the documentation, but they all have sane defaults. To improve performance, you can disable local map matching and bundle adjustment using do_local_bundle_adjustment and do_local_matching parameters.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using SLAM\n\nfocal = (910, 910)\nresolution = 1024\nprincipal_point = (resolution ÷ 2, resolution ÷ 2)\ndistortions = (0, 0, 0, 0)\n\ncamera = Camera(\n    focal..., principal_point..., distortions...,\n    resolution, resolution,\n)\nparams = Params(;stereo=false)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"After setting up parameters and camera we can create Slam Manager and launch its main run!(::SlamManager) routine as a separate thread. Under the hood, Slam Manager also launches two run! routines for the Estimator and Mapper.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"manager = SlamManager(camera, params)\nmanager_thread = Threads.@spawn run!(manager)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now you can feed manager with images and its timestamps to track.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"add_image!(manager, image, timestamp)","category":"page"},{"location":"tutorial/#Exit-SLAM","page":"Tutorial","title":"Exit SLAM","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To tell manager that you want to finish its job, set manager.exit_required to true and wait for the thread to finish wait(manager_thread).","category":"page"},{"location":"tutorial/#Stereo-mode","page":"Tutorial","title":"Stereo mode","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In stereo mode you also need to set right camera. For it, you need to specify transformation matrix that transforms points from the 0-th camera to this (referred as i-th camera) Ti0.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Ti0 = SMatrix{4, 4, Float64}(...)\nright_camera = SLAM.Camera(\n    focal..., principal_point..., distortions...,\n    resolution, resolution; Ti0)\nparams = Params(;stereo=true)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Launch manager, providing right camera:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"manager = SlamManager(camera, params; right_camera)\nmanager_thread = Threads.@spawn run!(manager)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In stereo mode, feed images:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"add_stereo_image!(manager, left_image, right_image, timestamp)","category":"page"},{"location":"tutorial/#Synchronizing-threads","page":"Tutorial","title":"Synchronizing threads","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Because different components take different time to run, you need to periodically synchronize them, so that they are roughly processing the same frames and not lagging behind.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Also because they start their work each in different time and due to JIT compilation, they take different time to compile.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Dirty way to do this right now is to check length of each of the queue and wait untill they become empty:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"q_size = get_queue_size(slam_manager)\nf_size = length(slam_manager.mapper.estimator.frame_queue)\nm_size = length(slam_manager.mapper.keyframe_queue)\nwhile q_size > 0 || f_size > 0 || m_size > 0\n    sleep(1e-2)\n    q_size = get_queue_size(slam_manager)\n    f_size = length(slam_manager.mapper.estimator.frame_queue)\n    m_size = length(slam_manager.mapper.keyframe_queue)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"note: Note\nIn future this ideally would not be needed.","category":"page"},{"location":"tutorial/#Visualization-and-saving-results","page":"Tutorial","title":"Visualization and saving results","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If you want to save all results, you can save Slam Manager directly as it contains all the processed information.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If you want to visualize the results as the algorithm runs, use SLAM.Visualizer and pass it as keyword to Slam Manager.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"visualizer = Visualizer((900, 600))\ndisplay(visualizer)\nmanager = SlamManager(params, camera; right_camera, visualizer)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Otherwise, you can use ReplaySaver instead of visualizer which will save all the necessary results for later visualization and replay.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can see example/kitty/main.jl for how to use it for visualization.","category":"page"},{"location":"api/params/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"api/params/","page":"Parameters","title":"Parameters","text":"Params\nreset!(::Params)","category":"page"},{"location":"api/params/#SLAM.Params","page":"Parameters","title":"SLAM.Params","text":"Parameters of the system.\n\nArguments:\n\nstereo::Bool: Set to false if in monocular mode, otherwise true.   Default is false.\nmax_nb_keypoints::Int64: Maximum number of keypoints to detect in the image.   Default is 1000.\nmax_distance::Int64: Cell size in pixels of the grid in Frame.   Each frame is divided into a grid, where each cell contains certain   number of keypoints. This grid is used when retrieving neighbouring   keypoints from the Frame.\nmax_ktl_distance::Float64: When doing optical flow tracking, it is done   by first tracking keypoint from previous frame to the current frame and   then in reverse. If the distance between keypoint in previous frame and   reverse tracked is greater than this distance, then that keypoint is   considered lost and discarded. Default is 1.0.\npyramid_levels::Int64: Number of pyramid levels to use during optical flow.   Set to 0 to use only original image. Otherwise if set to L, then total   number of levels is L + 1. Default is 3.\npyramid_σ::Float64: σ for the Gaussian blur, used when constructing   pyramids. Default is 1.0.\nwindow_size::Int64: Size of the window to use when doing optical flow   tracking. Default is 9.\ninitial_parallax::Float64: Average amount of the parallax needed   between the frames for the initialization. Default is 20.0.\nmax_reprojection_error::Float64: Maximum reprojection error for the   mappoint to be considered inlier. It is used in triangulation   and pose calculation. Default is 3.0.\nmin_cov_score::Int64: Minimum number of 3D MapPoints required   to perform Bundle-Adjustment. Default is 25.\nfiltering_ratio::Float64:   Number of good keypoints divided by the total number of keypoints   in a Frame. This is used to filter out non-informative Frames.   If frame ratio is greater than this value, then it is removed during   map filtering. Default is 0.9.\nmap_filtering::Bool: Set to true to perform local map matching.   The goal of this is to try to re-match lost 3D keypoints back into   the current frame.\nmax_projection_distance::Float64: Maximum distance between projected   and target pixels to consider keypoints being \"the same\".   Is is used during local map matching. Default is 2.0.\nmax_descriptor_distance::Float64: Maximum distance ratio between   descriptors to be considered similar. It is used during local map matching.   Default is 0.35. The lesser the value, the more accurate matching will be.   Should be in (0, 1) range.\n\nBelow variables are part of the SLAM state and should not change manually.\n\nvision_initialized::Bool: If true, then the Front-End was successfully   initialized.\nreset_required::Bool: Indicates if the visual part requires reset.   This could happen if the system is tracking too little points.\nlocal_ba_on::Bool: true, when Estimator is performing   Local Bundle Adjustment.\n\n\n\n\n\n","category":"type"},{"location":"api/params/#SLAM.reset!-Tuple{Params}","page":"Parameters","title":"SLAM.reset!","text":"reset!(p::Params)\n\nReset state of the system.\n\n\n\n\n\n","category":"method"}]
}
